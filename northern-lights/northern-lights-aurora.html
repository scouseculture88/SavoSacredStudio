<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aurora Borealis Complete</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Courier New', monospace;
            background: #000011;
            color: #fff;
            overflow: hidden;
            height: 100vh;
            user-select: none;
        }
        
        #canvas {
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            background: radial-gradient(circle at center, #001122 0%, #000000 100%);
            cursor: crosshair;
        }
        
        .header {
            position: fixed; top: 15px; left: 20px; z-index: 100;
            transition: opacity 0.5s ease;
        }
        .header.hidden { opacity: 0; }
        
        .title {
            font-size: 28px; font-weight: bold;
            background: linear-gradient(45deg, #00ffaa, #00aaff, #aa00ff);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            animation: glow 3s ease-in-out infinite alternate;
        }
        @keyframes glow { from { filter: brightness(1); } to { filter: brightness(1.5); } }
        
        .controls {
            position: fixed; top: 80px; right: 15px; width: 200px;
            background: rgba(0, 0, 30, 0.9); border: 1px solid rgba(0, 255, 170, 0.6);
            border-radius: 8px; padding: 12px; transition: transform 0.5s ease;
            z-index: 100; max-height: calc(100vh - 100px); overflow-y: auto;
        }
        .controls.hidden { transform: translateX(230px); }
        
        .control-group { margin-bottom: 12px; }
        .control-label {
            font-size: 10px; color: #00ffaa; margin-bottom: 4px;
            text-transform: uppercase; letter-spacing: 1px; font-weight: bold;
        }
        
        select, input[type="range"] {
            width: 100%; background: #000; color: #00aaff;
            border: 1px solid #00aaff; border-radius: 4px; font-size: 9px;
        }
        select { padding: 4px; font-family: 'Courier New', monospace; }
        
        input[type="range"] {
            height: 18px; -webkit-appearance: none;
            background: rgba(0, 170, 255, 0.2);
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 12px; height: 12px;
            border-radius: 50%; background: linear-gradient(135deg, #00ffaa, #00aaff);
            cursor: pointer; box-shadow: 0 0 8px rgba(0, 255, 170, 0.8);
        }
        
        .value-display {
            font-size: 8px; color: #aa00ff; margin-top: 2px;
            text-align: center; font-weight: bold;
        }
        
        .button {
            width: 100%; padding: 6px; margin: 2px 0;
            background: linear-gradient(45deg, rgba(0, 255, 170, 0.3), rgba(0, 170, 255, 0.3));
            border: 1px solid #00ffaa; border-radius: 4px; color: #00ffaa;
            cursor: pointer; font-size: 9px; text-transform: uppercase;
            font-family: 'Courier New', monospace; font-weight: bold;
            transition: all 0.3s ease;
        }
        .button:hover {
            background: linear-gradient(45deg, rgba(0, 255, 170, 0.5), rgba(0, 170, 255, 0.5));
            box-shadow: 0 0 10px rgba(0, 255, 170, 0.5);
        }
        
        .toggle {
            position: fixed; top: 20px; right: 20px; width: 40px; height: 40px;
            background: rgba(0, 0, 30, 0.9); border: 2px solid #00ffaa;
            border-radius: 50%; color: #00ffaa; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            font-size: 16px; z-index: 200; transition: all 0.3s ease;
        }
        .toggle:hover { box-shadow: 0 0 15px rgba(0, 255, 170, 0.7); }
        
        .info {
            position: fixed; bottom: 15px; left: 15px;
            background: rgba(0, 0, 30, 0.9); border: 1px solid rgba(0, 255, 170, 0.6);
            border-radius: 6px; padding: 8px; font-size: 8px; color: #00ffaa;
            max-width: 280px; transition: opacity 0.5s ease;
        }
        .info.hidden { opacity: 0; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="header" id="header"><div class="title">AURORA BOREALIS</div></div>
    <div class="toggle" id="toggle">⚡</div>
    
    <div class="controls" id="controls">
        <div class="control-group">
            <div class="control-label">Formation</div>
            <select id="formation">
                <option value="curtains">Curtain Formation</option>
                <option value="follow">Follow Particles</option>
                <option value="corona">Corona Burst</option>
                <option value="bands">Horizontal Bands</option>
                <option value="spiral">Spiral Formation</option>
            </select>
        </div>
        
        <div class="control-group">
            <div class="control-label">Colors</div>
            <select id="colors">
                <option value="multi" selected>All Colors</option>
                <option value="green">Green Only</option>
                <option value="pink">Pink Only</option>
                <option value="blue">Blue Only</option>
            </select>
        </div>
        
        <div class="control-group">
            <div class="control-label">Intensity</div>
            <input type="range" id="intensity" min="0.2" max="3" value="1.2" step="0.1">
            <div class="value-display" id="intensityVal">1.2</div>
        </div>
        
        <div class="control-group">
            <div class="control-label">Speed</div>
            <input type="range" id="speed" min="0.1" max="2" value="0.4" step="0.1">
            <div class="value-display" id="speedVal">0.4</div>
        </div>
        
        <div class="control-group">
            <div class="control-label">Particles</div>
            <input type="range" id="particles" min="100" max="800" value="350" step="25">
            <div class="value-display" id="particlesVal">350</div>
        </div>
        
        <div class="control-group">
            <div class="control-label">Magnetic Field</div>
            <input type="range" id="magnetic" min="0.1" max="3" value="1.2" step="0.1">
            <div class="value-display" id="magneticVal">1.2</div>
        </div>
        
        <div class="control-group">
            <div class="control-label">Solar Wind</div>
            <input type="range" id="wind" min="0" max="2" value="0.6" step="0.1">
            <div class="value-display" id="windVal">0.6</div>
        </div>
        
        <div class="control-group">
            <div class="control-label">Vortex Power</div>
            <input type="range" id="vortex" min="0.1" max="2" value="1.1" step="0.1">
            <div class="value-display" id="vortexVal">1.1</div>
        </div>
        
        <div class="control-group">
            <div class="control-label">Wave Coupling</div>
            <input type="range" id="coupling" min="0" max="1" value="0.7" step="0.1">
            <div class="value-display" id="couplingVal">0.7</div>
        </div>
        
        <div class="control-group">
            <button class="button" id="flare">Solar Flare</button>
            <button class="button" id="bloom">Nebula Bloom</button>
            <button class="button" id="storm">Geo Storm</button>
            <button class="button" id="reset">Reset</button>
        </div>
    </div>
    
    <div class="info" id="info">
        <strong>Aurora Physics:</strong> Charged solar particles interact with Earth's magnetosphere, creating spectacular light curtains at 80-400km altitude.
    </div>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width, height, particles = [], waves = [], stars = [], time = 0, hidden = false;
        
        // Settings
        let formation = 'curtains', colorMode = 'multi', intensity = 1.2, speed = 0.4;
        let particleCount = 350, magneticField = 1.2, solarWind = 0.6, vortexPower = 1.1, waveCoupling = 0.7;
        let solarFlare = false, nebulaBloom = false, geoStorm = false;
        
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            init();
        }
        
        function init() {
            particles = []; waves = []; stars = [];
            
            for (let i = 0; i < particleCount; i++) {
                particles.push({
                    x: Math.random() * width, y: Math.random() * height,
                    vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2,
                    energy: Math.random(), size: 1 + Math.random() * 3,
                    colorGroup: Math.floor(Math.random() * 4),
                    vortexAngle: Math.random() * Math.PI * 2,
                    vortexRadius: 0, targetX: 0, targetY: 0, inVortex: false
                });
            }
            
            for (let i = 0; i < 14; i++) {
                waves.push({
                    y: height * 0.1 + i * 30, amp: 20 + Math.random() * 25,
                    freq: 0.002 + Math.random() * 0.003, phase: Math.random() * Math.PI * 2,
                    speed: 0.005 + Math.random() * 0.008, flow: Math.random() * Math.PI * 2,
                    energy: 0.4 + Math.random() * 0.6, colorGroup: i % 4, attractorX: width / 2
                });
            }
            
            for (let i = 0; i < 120; i++) {
                stars.push({
                    x: Math.random() * width, y: Math.random() * height,
                    brightness: Math.random(), twinkle: Math.random() * Math.PI,
                    size: 0.5 + Math.random() * 1.5
                });
            }
        }
        
        function getColor(mode, energy, alpha = 1, colorGroup = 0) {
            const colors = [
                () => `rgba(${50 + energy * 100}, ${200 + energy * 55}, ${50 + energy * 50}, ${alpha})`,
                () => `rgba(${200 + energy * 55}, ${100 + energy * 100}, ${200 + energy * 50}, ${alpha})`,
                () => `rgba(${100 + energy * 50}, ${150 + energy * 100}, ${200 + energy * 55}, ${alpha})`,
                () => `rgba(${200 + energy * 55}, ${180 + energy * 55}, ${50 + energy * 100}, ${alpha})`
            ];
            
            switch(mode) {
                case 'green': return colors[0]();
                case 'pink': return colors[1]();
                case 'blue': return colors[2]();
                default: return colors[colorGroup % 4]();
            }
        }
        
        function getVortexCenters() {
            let centers = [];
            switch(formation) {
                case 'follow':
                    const densityMap = new Map();
                    particles.forEach(p => {
                        const key = `${Math.floor(p.x / 120) * 120},${Math.floor(p.y / 120) * 120}`;
                        densityMap.set(key, (densityMap.get(key) || 0) + 1);
                    });
                    centers = Array.from(densityMap.entries())
                        .sort((a, b) => b[1] - a[1]).slice(0, 4)
                        .map((entry, i) => {
                            const [x, y] = entry[0].split(',').map(Number);
                            return { x: x + 60, y: y + 60, group: i };
                        });
                    break;
                case 'corona':
                    for (let i = 0; i < 4; i++) {
                        const angle = (i / 4) * Math.PI * 2 + time * 0.01;
                        const radius = 120 + Math.sin(time * 0.02 + i) * 40;
                        centers.push({
                            x: width/2 + Math.cos(angle) * radius,
                            y: height/2 + Math.sin(angle) * radius, group: i
                        });
                    }
                    break;
                case 'spiral':
                    for (let i = 0; i < 4; i++) {
                        const angle = time * 0.015 + (i * Math.PI / 2);
                        const radius = 80 + i * 35 + Math.sin(time * 0.01) * 25;
                        centers.push({
                            x: width/2 + Math.cos(angle) * radius,
                            y: height/2 + Math.sin(angle) * radius, group: i
                        });
                    }
                    break;
                default:
                    centers = [
                        { x: width * 0.2, y: height * 0.3, group: 0 },
                        { x: width * 0.8, y: height * 0.4, group: 1 },
                        { x: width * 0.3, y: height * 0.65, group: 2 },
                        { x: width * 0.7, y: height * 0.75, group: 3 }
                    ];
            }
            return centers.length ? centers : [{ x: width/2, y: height/2, group: 0 }];
        }
        
        function update() {
            const vortexCenters = getVortexCenters();
            
            particles.forEach(p => {
                p.vx += solarWind * 0.08 * (Math.random() - 0.5);
                p.vy += solarWind * 0.04 * (Math.random() - 0.5);
                
                if (p.colorGroup % 2 === 0) {
                    p.vx += Math.sin(p.y * 0.008 + time * 0.02) * magneticField * 0.08;
                }
                
                const vortex = vortexCenters[p.colorGroup % vortexCenters.length];
                if (vortex) {
                    const dist = Math.sqrt((p.x - vortex.x) ** 2 + (p.y - vortex.y) ** 2);
                    if (dist < 140 && Math.random() < 0.025 * vortexPower) {
                        p.inVortex = true; p.targetX = vortex.x; p.targetY = vortex.y; p.vortexRadius = dist;
                    }
                }
                
                if (p.inVortex) {
                    p.vortexAngle += (0.08 + p.energy * 0.1) * vortexPower;
                    p.vortexRadius *= 0.975;
                    const spiralX = p.targetX + Math.cos(p.vortexAngle) * p.vortexRadius;
                    const spiralY = p.targetY + Math.sin(p.vortexAngle) * p.vortexRadius;
                    p.vx = (spiralX - p.x) * 0.12; p.vy = (spiralY - p.y) * 0.12;
                    
                    if (p.vortexRadius < 4) {
                        p.inVortex = false;
                        const angle = Math.random() * Math.PI * 2, exitSpeed = 1.5 + Math.random() * 2.5;
                        p.vx = Math.cos(angle) * exitSpeed; p.vy = Math.sin(angle) * exitSpeed;
                        p.energy = Math.min(1, p.energy + 0.35);
                    }
                } else {
                    p.x += p.vx * speed * intensity; p.y += p.vy * speed * intensity;
                }
                
                if (solarFlare || geoStorm) {
                    const mult = geoStorm ? 2.2 : 1.4;
                    const dx = p.x - width/2, dy = p.y - height/3, dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 180 * mult) {
                        const force = ((180 * mult) - dist) / (180 * mult);
                        p.vx += (Math.random() - 0.5) * force * 3.5 * mult;
                        p.vy += (Math.random() - 0.5) * force * 3.5 * mult;
                        p.energy = Math.min(1, p.energy + force * 0.25); p.inVortex = false;
                    }
                }
                
                if (p.x < 0) p.x = width; if (p.x > width) p.x = 0;
                if (p.y < 0) p.y = height; if (p.y > height) p.y = 0;
                if (!p.inVortex) p.energy = Math.max(0.15, p.energy - 0.0006);
            });
            
            waves.forEach((w, i) => {
                w.phase += w.speed * speed; w.flow += 0.012;
                
                switch(formation) {
                    case 'follow':
                        const nearby = particles.filter(p => p.colorGroup === w.colorGroup && Math.abs(p.y - w.y) < 70);
                        if (nearby.length > 0) {
                            const avgX = nearby.reduce((s, p) => s + p.x, 0) / nearby.length;
                            const avgE = nearby.reduce((s, p) => s + p.energy, 0) / nearby.length;
                            w.attractorX = avgX; w.energy = 0.3 + avgE * 0.6 * waveCoupling;
                            w.amp = 15 + avgE * 35 * waveCoupling;
                        }
                        break;
                    case 'corona':
                        w.energy = 0.45 + 0.35 * Math.sin(time * 0.025 + i * 0.4);
                        w.amp = 25 + 25 * Math.sin(time * 0.018 + i);
                        break;
                    default:
                        w.energy = 0.35 + 0.35 * Math.sin(w.flow + i * 0.4);
                        w.amp = 20 + 15 * Math.sin(time * 0.008 + i * 0.25);
                }
                
                if (solarFlare || geoStorm) {
                    const mult = geoStorm ? 1.6 : 1.25;
                    w.amp = Math.min(80, w.amp * mult); w.energy = Math.min(1, w.energy * mult);
                } else {
                    w.amp = Math.max(15, w.amp * 0.9985); w.energy = Math.max(0.25, w.energy * 0.9992);
                }
            });
        }
        
        function draw() {
            ctx.fillStyle = 'rgba(0, 0, 17, 0.08)'; ctx.fillRect(0, 0, width, height);
            
            stars.forEach(s => {
                s.twinkle += 0.04;
                const brightness = s.brightness * (0.6 + 0.4 * Math.sin(s.twinkle));
                ctx.fillStyle = `rgba(255, 255, 255, ${brightness})`;
                ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2); ctx.fill();
            });
            
            waves.forEach((w, i) => {
                for (let offset = -6; offset <= 6; offset += 3) {
                    const alpha = (1 - Math.abs(offset) / 6) * w.energy * intensity * 0.75;
                    ctx.strokeStyle = getColor(colorMode, w.energy, alpha, w.colorGroup);
                    ctx.lineWidth = 1.5 + w.energy * 2.5; ctx.lineCap = 'round';
                    
                    ctx.beginPath();
                    for (let x = 0; x <= width; x += 5) {
                        let waveHeight = Math.sin(x * w.freq + w.phase) * w.amp * intensity;
                        if (formation === 'follow' && w.attractorX) {
                            const influence = Math.exp(-Math.abs(x - w.attractorX) / 150) * waveCoupling;
                            waveHeight += Math.sin(x * 0.01 + w.flow) * 8 * influence;
                        }
                        const y = w.y + waveHeight + Math.sin(x * 0.006 + w.flow) * 10 + offset;
                        if (x === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
                
                for (let x = 0; x <= width; x += 12) {
                    if (Math.random() < w.energy * 0.35) {
                        let waveHeight = Math.sin(x * w.freq + w.phase) * w.amp * intensity;
                        if (formation === 'follow' && w.attractorX) {
                            waveHeight += Math.sin(x * 0.01 + w.flow) * 8 * Math.exp(-Math.abs(x - w.attractorX) / 150) * waveCoupling;
                        }
                        const y = w.y + waveHeight + Math.sin(x * 0.006 + w.flow) * 10;
                        const size = 1 + w.energy * 2;
                        ctx.fillStyle = getColor(colorMode, 1, w.energy * 0.8, w.colorGroup);
                        ctx.beginPath(); ctx.arc(x, y, size, 0, Math.PI * 2); ctx.fill();
                        ctx.shadowColor = getColor(colorMode, 1, 0.5, w.colorGroup);
                        ctx.shadowBlur = size * 3; ctx.fill(); ctx.shadowBlur = 0;
                    }
                }
            });
            
            particles.forEach(p => {
                const size = p.size * p.energy * intensity;
                const color = getColor(colorMode, p.energy, p.energy * 0.9, p.colorGroup);
                
                if (p.inVortex) {
                    ctx.strokeStyle = getColor(colorMode, p.energy, p.energy * 0.5, p.colorGroup);
                    ctx.lineWidth = size * 0.4; ctx.lineCap = 'round'; ctx.beginPath();
                    for (let i = 0; i < 4; i++) {
                        const angle = p.vortexAngle - i * 0.25, radius = p.vortexRadius + i * 2;
                        const x = p.targetX + Math.cos(angle) * radius, y = p.targetY + Math.sin(angle) * radius;
                        if (i === 0) ctx.moveTo(p.x, p.y); else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
                
                ctx.fillStyle = color; ctx.beginPath(); ctx.arc(p.x, p.y, size, 0, Math.PI * 2); ctx.fill();
                
                if (p.energy > 0.7 || p.inVortex) {
                    ctx.shadowColor = color; ctx.shadowBlur = size * (p.inVortex ? 6 : 3);
                    ctx.fill(); ctx.shadowBlur = 0;
                }
                
                if (p.inVortex && Math.random() < 0.3) {
                    ctx.fillStyle = getColor(colorMode, 1, 1, p.colorGroup);
                    ctx.beginPath();
                    ctx.arc(p.x + (Math.random() - 0.5) * 8, p.y + (Math.random() - 0.5) * 8, 1, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            if (solarFlare || geoStorm) {
                const size = geoStorm ? 250 : 180;
                const intensity = Math.sin(time * 0.1) * 0.5 + 0.5;
                const grad = ctx.createRadialGradient(width/2, height/3, 0, width/2, height/3, size);
                grad.addColorStop(0, `rgba(255, 255, 0, ${intensity * (geoStorm ? 0.8 : 0.6)})`);
                grad.addColorStop(0.5, `rgba(255, 100, 0, ${intensity * 0.3})`);
                grad.addColorStop(1, 'rgba(255, 0, 0, 0)');
                ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(width/2, height/3, size, 0, Math.PI * 2); ctx.fill();
            }
            
            if (nebulaBloom) {
                const bloomSize = 200 + Math.sin(time * 0.05) * 100;
                const grad = ctx.createRadialGradient(width/2, height/2, 0, width/2, height/2, bloomSize);
                grad.addColorStop(0, getColor(colorMode, 1, 0.3, 0));
                grad.addColorStop(0.7, getColor(colorMode, 0.5, 0.1, 1));
                grad.addColorStop(1, getColor(colorMode, 0.2, 0, 2));
                ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(width/2, height/2, bloomSize, 0, Math.PI * 2); ctx.fill();
            }
        }
        
        function animate() { time++; update(); draw(); requestAnimationFrame(animate); }
        
        function toggleUI() {
            hidden = !hidden;
            ['header', 'controls', 'info'].forEach(id => {
                document.getElementById(id).classList.toggle('hidden', hidden);
            });
            document.getElementById('toggle').textContent = hidden ? '👁️' : '⚡';
        }
        
        function updateValue(id, val) { document.getElementById(id + 'Val').textContent = val; }
        
        // Event listeners
        document.getElementById('toggle').onclick = toggleUI;
        document.getElementById('formation').onchange = e => formation = e.target.value;
        document.getElementById('colors').onchange = e => colorMode = e.target.value;
        document.getElementById('intensity').oninput = e => { intensity = +e.target.value; updateValue('intensity', intensity); };
        document.getElementById('speed').oninput = e => { speed = +e.target.value; updateValue('speed', speed); };
        document.getElementById('particles').oninput = e => { particleCount = +e.target.value; updateValue('particles', particleCount); init(); };
        document.getElementById('magnetic').oninput = e => { magneticField = +e.target.value; updateValue('magnetic', magneticField); };
        document.getElementById('wind').oninput = e => { solarWind = +e.target.value; updateValue('wind', solarWind); };
        document.getElementById('vortex').oninput = e => { vortexPower = +e.target.value; updateValue('vortex', vortexPower); };
        document.getElementById('coupling').oninput = e => { waveCoupling = +e.target.value; updateValue('coupling', waveCoupling); };
        
        document.getElementById('flare').onclick = () => { solarFlare = true; setTimeout(() => solarFlare = false, 4000); };
        document.getElementById('bloom').onclick = () => { nebulaBloom = true; setTimeout(() => nebulaBloom = false, 6000); };
        document.getElementById('storm').onclick = () => { geoStorm = true; setTimeout(() => geoStorm = false, 8000); };
        document.getElementById('reset').onclick = () => { solarFlare = nebulaBloom = geoStorm = false; time = 0; init(); };
        
        canvas.onclick = e => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left, y = e.clientY - rect.top;
            particles.forEach(p => {
                const dx = p.x - x, dy = p.y - y, dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < 80) {
                    const force = (80 - dist) / 80;
                    p.vx += (dx / dist) * force * 3; p.vy += (dy / dist) * force * 3;
                    p.energy = Math.min(1, p.energy + force * 0.5);
                }
            });
        };
        
        canvas.ontouchstart = e => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left, y = touch.clientY - rect.top;
            particles.forEach(p => {
                const dx = p.x - x, dy = p.y - y, dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < 80) {
                    const force = (80 - dist) / 80;
                    p.vx += (dx / dist) * force * 3; p.vy += (dy / dist) * force * 3;
                    p.energy = Math.min(1, p.energy + force * 0.5);
                }
            });
        };
        
        window.onresize = resize;
        resize(); animate();
    </script>
</body>
</html>
