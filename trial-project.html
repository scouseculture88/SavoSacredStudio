<!DOCTYPE html>
<html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Hybrid Kaleidoscope</title>
<style>
body{margin:0;padding:0;background:#000;font-family:'Courier New',monospace;overflow:hidden}
canvas{display:block;background:#000}
.controls{position:absolute;top:10px;left:10px;color:#ff6b9d;z-index:100;background:rgba(30,10,30,0.95);padding:8px;border-radius:8px;border:1px solid #ff6b9d;backdrop-filter:blur(10px);box-shadow:0 0 20px rgba(255,107,157,0.3);font-size:11px;max-width:280px}
.controls.minimized{padding:6px 8px;max-width:120px}
.controls-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;cursor:pointer}
.controls.minimized .controls-header{margin-bottom:0}
.title{font-weight:bold;text-shadow:0 0 10px #ff6b9d;font-size:11px;background:linear-gradient(45deg,#ff6b9d,#c44569);-webkit-background-clip:text;-webkit-text-fill-color:transparent}
.minimize-btn{background:linear-gradient(45deg,#ff6b9d,#c44569);border:none;color:white;border-radius:50%;width:18px;height:18px;cursor:pointer;font-weight:bold;text-align:center;box-shadow:0 0 10px rgba(255,107,157,0.5);font-size:10px;line-height:18px;flex-shrink:0}
.control-group{margin-bottom:6px}
.control-group label{display:block;margin-bottom:3px;font-size:10px;text-shadow:0 0 5px #ff6b9d;font-weight:500}
select,input[type="range"],button{background:rgba(40,20,40,0.9);color:#ff6b9d;border:1px solid #ff6b9d;border-radius:4px;padding:2px 4px;font-size:10px}
button{cursor:pointer;font-weight:bold;text-align:center;padding:4px 8px}
button:hover{background:rgba(255,107,157,0.25);box-shadow:0 0 8px rgba(255,107,157,0.4)}
button.active{background:rgba(255,107,157,0.4);box-shadow:0 0 10px rgba(255,107,157,0.6)}
.mode-manual{background:linear-gradient(45deg,#0080ff,#0060cc);color:white}
.mode-auto{background:linear-gradient(45deg,#00ff00,#00aa00);color:white}
.mode-hybrid{background:linear-gradient(45deg,#ff8000,#cc6000);color:white}
.recording{background:rgba(255,0,0,0.4);border-color:#ff0000;color:#ff0000;animation:recordPulse 1s infinite}
@keyframes recordPulse{0%,100%{opacity:1;transform:scale(1)}50%{opacity:0.8;transform:scale(1.02)}}
input[type="range"]{width:100%;height:4px}
.status-info{position:absolute;top:10px;right:10px;color:#ff6b9d;background:rgba(30,10,30,0.95);padding:6px 10px;border-radius:6px;backdrop-filter:blur(10px);box-shadow:0 0 15px rgba(255,107,157,0.3);z-index:100;font-size:10px}
.control-content{display:block}
.controls.minimized .control-content{display:none}
</style></head><body>
<canvas id="canvas"></canvas>
<div class="controls" id="controls">
<div class="controls-header" onclick="toggleControls()">
<div class="title">HYBRID KALEIDOSCOPE</div>
<button class="minimize-btn" id="minimizeBtn">-</button>
</div>
<div class="control-content">
<div class="control-group">
<button id="modeBtn" class="mode-manual">MANUAL</button>
</div>
<div class="control-group"><label>AI Behavior</label>
<select id="aiMode">
<option value="geometric">Geometric</option>
<option value="organic">Organic Flow</option>
<option value="spiral">Spiral</option>
<option value="mandala">Mandala</option>
<option value="chaotic">Chaotic</option>
</select></div>
<div class="control-group"><label>Speed: <span id="speedVal">50</span>%</label><input type="range" id="speed" min="1" max="100" value="50"></div>
<div class="control-group"><label>Mirror Pattern</label>
<select id="mode">
<option value="3">Triangle (3-way)</option>
<option value="4">Square (4-way)</option>
<option value="5">Pentagon (5-way)</option>
<option value="6">Hexagonal (6-way)</option>
<option value="7">Heptagon (7-way)</option>
<option value="8">Octagonal (8-way)</option>
<option value="9">Nonagon (9-way)</option>
<option value="10">Decagon (10-way)</option>
<option value="12">Dodecagon (12-way)</option>
<option value="16">16-way Advanced</option>
<option value="24">24-way Ultra</option>
<option value="36">36-way LEGENDARY</option>
<option value="48">48-way GODLIKE</option>
<option value="60">60-way INFINITE</option>
</select></div>
<div class="control-group"><label>Brush: <span id="brushVal">25</span>px</label><input type="range" id="brush" min="2" max="100" value="25"></div>
<div class="control-group"><label>Glow: <span id="glowVal">80</span>%</label><input type="range" id="glow" min="20" max="150" value="80"></div>
<div class="control-group">
<button id="soundBtn">Enable Sounds</button></div>
<div class="control-group"><label>Sound Mode</label><select id="soundMode">
<option value="solfeggio">Solfeggio Frequencies</option>
<option value="waterdrops">Water Drops</option>
<option value="rain">Gentle Rain</option>
<option value="waves">Ocean Waves</option>
<option value="waterfall">Waterfall Flow</option>
<option value="birds">Forest Birds</option>
<option value="wind">Wind Through Trees</option>
<option value="chimes">Wind Chimes</option>
<option value="bells">Tibetan Bells</option>
<option value="piano">Soft Piano</option>
</select></div>
<div class="control-group"><label>Volume: <span id="volVal">80</span>%</label><input type="range" id="volume" min="0" max="100" value="80"></div>
<div class="control-group">
<button id="recordBtn">Record Video</button></div>
<div class="control-group"><label>Quality</label><select id="recordQuality">
<option value="ultramax">ULTRA MAX (32 Mbps, 120 FPS)</option>
<option value="cinematic">Cinematic (24 Mbps, 120 FPS)</option>
<option value="professional">Professional (16 Mbps, 60 FPS)</option>
<option value="high">High Quality (12 Mbps, 60 FPS)</option>
<option value="standard">Standard (8 Mbps, 30 FPS)</option>
</select></div>
<div class="control-group">
<button onclick="clearCanvas()">Clear</button>
<button onclick="saveImage()">Save</button>
</div>
</div></div>

<div class="status-info" id="statusInfo">Manual Mode</div>

<script>
const canvas=document.getElementById('canvas'),ctx=canvas.getContext('2d');
canvas.width=window.innerWidth;canvas.height=window.innerHeight;

let currentMode='manual',isDrawing=false,isGenerating=false;
let lastX=0,lastY=0,aiX=canvas.width/2,aiY=canvas.height/2;
let hue=0,time=0,audioContext=null,soundEnabled=false,lastSoundTime=0;
let phaseProgress=0,generationInterval=null;
let mediaRecorder=null,recordedChunks=[],isRecording=false,recordingDestination=null;

const centerX=canvas.width/2,centerY=canvas.height/2;
const modeBtn=document.getElementById('modeBtn');
const aiMode=document.getElementById('aiMode');
const mode=document.getElementById('mode');
const speed=document.getElementById('speed');
const brush=document.getElementById('brush');
const glow=document.getElementById('glow');
const soundBtn=document.getElementById('soundBtn');
const soundMode=document.getElementById('soundMode');
const volume=document.getElementById('volume');
const recordBtn=document.getElementById('recordBtn');
const recordQuality=document.getElementById('recordQuality');
const statusInfo=document.getElementById('statusInfo');

function toggleControls(){
    const c=document.getElementById('controls'),b=document.getElementById('minimizeBtn');
    c.classList.toggle('minimized');b.textContent=c.classList.contains('minimized')?'+':'-';
}

function switchMode(){
    if(currentMode==='manual'){
        currentMode='auto';modeBtn.textContent='AUTO';modeBtn.className='mode-auto';
        statusInfo.textContent='Auto Mode';startGeneration();
    }else if(currentMode==='auto'){
        currentMode='hybrid';modeBtn.textContent='HYBRID';modeBtn.className='mode-hybrid';
        statusInfo.textContent='Hybrid Mode';
    }else{
        currentMode='manual';modeBtn.textContent='MANUAL';modeBtn.className='mode-manual';
        statusInfo.textContent='Manual Mode';stopGeneration();
    }
}

function startGeneration(){
    if(!isGenerating&&(currentMode==='auto'||currentMode==='hybrid')){
        isGenerating=true;generationInterval=setInterval(generateStep,16);
    }
}

function stopGeneration(){
    if(isGenerating){
        isGenerating=false;
        if(generationInterval){clearInterval(generationInterval);generationInterval=null;}
    }
}

function clearCanvas(){ctx.fillStyle='#000';ctx.fillRect(0,0,canvas.width,canvas.height);}

function saveImage(){
    const link=document.createElement('a');
    link.download=`hybrid_kaleidoscope_${Date.now()}.png`;
    link.href=canvas.toDataURL();link.click();
}

function startRecord(){
    if(!isRecording){
        recordedChunks=[];
        
        // Create recording audio destination if audio is enabled
        if(audioContext && soundEnabled){
            recordingDestination = audioContext.createMediaStreamDestination();
        }
        
        const canvasStream = canvas.captureStream(60);
        let combinedStream = canvasStream;
        
        // Combine video and audio if audio recording is available
        if(recordingDestination && soundEnabled){
            const audioStream = recordingDestination.stream;
            combinedStream = new MediaStream([
                ...canvasStream.getVideoTracks(),
                ...audioStream.getAudioTracks()
            ]);
        }
        
        const quality={ultramax:8000000,cinematic:6000000,professional:4000000,high:3000000,standard:2000000};
        
        mediaRecorder=new MediaRecorder(combinedStream,{videoBitsPerSecond:quality[recordQuality.value]||4000000});
        
        mediaRecorder.ondataavailable=e=>{if(e.data.size>0)recordedChunks.push(e.data);};
        
        mediaRecorder.onstop=()=>{
            const blob=new Blob(recordedChunks,{type:'video/webm'});
            const url=URL.createObjectURL(blob);
            const a=document.createElement('a');
            a.style.display='none';a.href=url;
            a.download=`kaleidoscope_${soundEnabled ? 'with_audio' : 'video_only'}_${Date.now()}.webm`;
            document.body.appendChild(a);a.click();document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            // Clean up recording destination
            recordingDestination = null;
        };
        
        mediaRecorder.start();isRecording=true;recordBtn.textContent='Stop Recording';
        recordBtn.classList.add('recording');
        
        statusInfo.textContent = soundEnabled ? 'Recording with Audio' : 'Recording Video Only';
        
    }else{
        if(mediaRecorder)mediaRecorder.stop();
        isRecording=false;recordBtn.textContent='Record Video';
        recordBtn.classList.remove('recording');
        statusInfo.textContent = currentMode === 'manual' ? 'Manual Mode' : 
                                currentMode === 'auto' ? 'Auto Mode' : 'Hybrid Mode';
    }
}

function initAudio(){
    if(!audioContext){
        try{audioContext=new(window.AudioContext||window.webkitAudioContext)();}
        catch(e){console.log('Audio not supported');}
    }
}

function toggleSound(){
    if(!soundEnabled){
        initAudio();
        if(audioContext){soundEnabled=true;soundBtn.textContent='Disable Sounds';soundBtn.classList.add('active');}
    }else{
        soundEnabled=false;soundBtn.textContent='Enable Sounds';soundBtn.classList.remove('active');
    }
}

function playSound(colorValue){
    if(!soundEnabled||!audioContext)return;
    const now=Date.now();
    if(now-lastSoundTime<50)return;lastSoundTime=now;
    
    try{
        if(audioContext.state==='suspended')audioContext.resume();
        const vol=volume.value/100*0.15;
        
        // Create master gain for this sound
        const masterGain = audioContext.createGain();
        masterGain.connect(audioContext.destination);
        
        // If recording, also connect to recording destination
        if(isRecording && recordingDestination){
            masterGain.connect(recordingDestination);
        }
        
        switch(soundMode.value){
            case 'solfeggio':
                const frequencies=[174,285,396,417,528,639,741,852,963];
                const freq=frequencies[Math.floor((colorValue/360)*frequencies.length)]||528;
                const osc=audioContext.createOscillator(),gain=audioContext.createGain();
                osc.connect(gain);gain.connect(masterGain);
                osc.type='sine';osc.frequency.setValueAtTime(freq,audioContext.currentTime);
                gain.gain.setValueAtTime(0,audioContext.currentTime);
                gain.gain.linearRampToValueAtTime(vol*0.6,audioContext.currentTime+0.1);
                gain.gain.exponentialRampToValueAtTime(0.001,audioContext.currentTime+1.2);
                osc.start(audioContext.currentTime);osc.stop(audioContext.currentTime+1.2);
                break;
            case 'waterdrops':
                const osc1=audioContext.createOscillator(),osc2=audioContext.createOscillator();
                const gain1=audioContext.createGain(),filter=audioContext.createBiquadFilter();
                osc1.connect(filter);osc2.connect(filter);filter.connect(gain1);gain1.connect(masterGain);
                osc1.frequency.setValueAtTime(800,audioContext.currentTime);
                osc1.frequency.exponentialRampToValueAtTime(200,audioContext.currentTime+0.1);
                osc2.frequency.setValueAtTime(400,audioContext.currentTime);
                osc2.frequency.exponentialRampToValueAtTime(100,audioContext.currentTime+0.15);
                osc1.type='sine';osc2.type='triangle';filter.type='lowpass';
                filter.frequency.setValueAtTime(1200,audioContext.currentTime);
                filter.frequency.exponentialRampToValueAtTime(300,audioContext.currentTime+0.2);
                gain1.gain.setValueAtTime(0,audioContext.currentTime);
                gain1.gain.linearRampToValueAtTime(vol,audioContext.currentTime+0.01);
                gain1.gain.exponentialRampToValueAtTime(0.001,audioContext.currentTime+0.3);
                osc1.start(audioContext.currentTime);osc1.stop(audioContext.currentTime+0.3);
                osc2.start(audioContext.currentTime);osc2.stop(audioContext.currentTime+0.3);
                break;
            case 'rain':
                const bufferSize=audioContext.sampleRate*0.5;
                const noiseBuffer=audioContext.createBuffer(1,bufferSize,audioContext.sampleRate);
                const output=noiseBuffer.getChannelData(0);
                for(let i=0;i<bufferSize;i++)output[i]=Math.random()*2-1;
                const noiseSource=audioContext.createBufferSource();
                const filter2=audioContext.createBiquadFilter(),gain2=audioContext.createGain();
                noiseSource.buffer=noiseBuffer;noiseSource.connect(filter2);
                filter2.connect(gain2);gain2.connect(audioContext.destination);
                filter2.type='highpass';filter2.frequency.setValueAtTime(8000,audioContext.currentTime);
                gain2.gain.setValueAtTime(0,audioContext.currentTime);
                gain2.gain.linearRampToValueAtTime(vol*0.3,audioContext.currentTime+0.05);
                gain2.gain.exponentialRampToValueAtTime(0.001,audioContext.currentTime+0.4);
                noiseSource.start(audioContext.currentTime);noiseSource.stop(audioContext.currentTime+0.4);
                break;
            case 'waves':
                const oscW=audioContext.createOscillator(),lfo=audioContext.createOscillator();
                const gainW=audioContext.createGain(),lfoGain=audioContext.createGain();
                const filterW=audioContext.createBiquadFilter();
                lfo.connect(lfoGain);lfoGain.connect(filterW.frequency);
                oscW.connect(filterW);filterW.connect(gainW);gainW.connect(audioContext.destination);
                oscW.type='sawtooth';oscW.frequency.setValueAtTime(60,audioContext.currentTime);
                lfo.type='sine';lfo.frequency.setValueAtTime(0.5,audioContext.currentTime);
                lfoGain.gain.setValueAtTime(200,audioContext.currentTime);
                filterW.type='lowpass';filterW.frequency.setValueAtTime(400,audioContext.currentTime);
                filterW.Q.setValueAtTime(2,audioContext.currentTime);
                gainW.gain.setValueAtTime(0,audioContext.currentTime);
                gainW.gain.linearRampToValueAtTime(vol*0.4,audioContext.currentTime+0.2);
                gainW.gain.exponentialRampToValueAtTime(0.001,audioContext.currentTime+1.5);
                oscW.start(audioContext.currentTime);oscW.stop(audioContext.currentTime+1.5);
                lfo.start(audioContext.currentTime);lfo.stop(audioContext.currentTime+1.5);
                break;
            case 'waterfall':
                const bufferSize2=audioContext.sampleRate*0.8;
                const noiseBuffer2=audioContext.createBuffer(1,bufferSize2,audioContext.sampleRate);
                const output2=noiseBuffer2.getChannelData(0);
                for(let i=0;i<bufferSize2;i++)output2[i]=Math.random()*2-1;
                const noiseSource2=audioContext.createBufferSource();
                const filter3=audioContext.createBiquadFilter(),filter4=audioContext.createBiquadFilter();
                const gain3=audioContext.createGain();
                noiseSource2.buffer=noiseBuffer2;noiseSource2.connect(filter3);
                filter3.connect(filter4);filter4.connect(gain3);gain3.connect(audioContext.destination);
                filter3.type='bandpass';filter3.frequency.setValueAtTime(2000,audioContext.currentTime);
                filter3.Q.setValueAtTime(1,audioContext.currentTime);
                filter4.type='highpass';filter4.frequency.setValueAtTime(1000,audioContext.currentTime);
                gain3.gain.setValueAtTime(0,audioContext.currentTime);
                gain3.gain.linearRampToValueAtTime(vol*0.5,audioContext.currentTime+0.1);
                gain3.gain.exponentialRampToValueAtTime(0.001,audioContext.currentTime+1.0);
                noiseSource2.start(audioContext.currentTime);noiseSource2.stop(audioContext.currentTime+1.0);
                break;
            case 'birds':
                const baseFreq=800+(colorValue/360)*1200;
                const oscB=audioContext.createOscillator(),gainB=audioContext.createGain();
                const filterB=audioContext.createBiquadFilter();
                oscB.connect(filterB);filterB.connect(gainB);gainB.connect(audioContext.destination);
                oscB.type='sine';oscB.frequency.setValueAtTime(baseFreq,audioContext.currentTime);
                oscB.frequency.linearRampToValueAtTime(baseFreq*1.5,audioContext.currentTime+0.05);
                oscB.frequency.exponentialRampToValueAtTime(baseFreq*0.8,audioContext.currentTime+0.2);
                filterB.type='bandpass';filterB.frequency.setValueAtTime(baseFreq,audioContext.currentTime);
                filterB.Q.setValueAtTime(5,audioContext.currentTime);
                gainB.gain.setValueAtTime(0,audioContext.currentTime);
                gainB.gain.linearRampToValueAtTime(vol*0.6,audioContext.currentTime+0.02);
                gainB.gain.exponentialRampToValueAtTime(0.001,audioContext.currentTime+0.3);
                oscB.start(audioContext.currentTime);oscB.stop(audioContext.currentTime+0.3);
                break;
            case 'wind':
                const bufferSize3=audioContext.sampleRate*1.2;
                const noiseBuffer3=audioContext.createBuffer(1,bufferSize3,audioContext.sampleRate);
                const output3=noiseBuffer3.getChannelData(0);
                for(let i=0;i<bufferSize3;i++)output3[i]=Math.random()*2-1;
                const noiseSource3=audioContext.createBufferSource();
                const filter5=audioContext.createBiquadFilter(),gain4=audioContext.createGain();
                const lfo2=audioContext.createOscillator(),lfoGain2=audioContext.createGain();
                lfo2.connect(lfoGain2);lfoGain2.connect(gain4.gain);
                noiseSource3.buffer=noiseBuffer3;noiseSource3.connect(filter5);
                filter5.connect(gain4);gain4.connect(audioContext.destination);
                filter5.type='lowpass';filter5.frequency.setValueAtTime(600,audioContext.currentTime);
                lfo2.type='sine';lfo2.frequency.setValueAtTime(0.3,audioContext.currentTime);
                lfoGain2.gain.setValueAtTime(vol*0.3,audioContext.currentTime);
                gain4.gain.setValueAtTime(vol*0.2,audioContext.currentTime);
                noiseSource3.start(audioContext.currentTime);noiseSource3.stop(audioContext.currentTime+1.2);
                lfo2.start(audioContext.currentTime);lfo2.stop(audioContext.currentTime+1.2);
                break;
            case 'chimes':
                const frequencies2=[523,659,784,1047,1319];
                const freqC=frequencies2[Math.floor((colorValue/360)*frequencies2.length)];
                const oscC=audioContext.createOscillator(),gainC=audioContext.createGain();
                const filterC=audioContext.createBiquadFilter();
                oscC.connect(filterC);filterC.connect(gainC);gainC.connect(audioContext.destination);
                oscC.type='sine';oscC.frequency.setValueAtTime(freqC,audioContext.currentTime);
                filterC.type='highpass';filterC.frequency.setValueAtTime(200,audioContext.currentTime);
                gainC.gain.setValueAtTime(0,audioContext.currentTime);
                gainC.gain.linearRampToValueAtTime(vol*0.7,audioContext.currentTime+0.05);
                gainC.gain.exponentialRampToValueAtTime(0.001,audioContext.currentTime+2.0);
                oscC.start(audioContext.currentTime);oscC.stop(audioContext.currentTime+2.0);
                break;
            case 'bells':
                const baseFreqB=200+(colorValue/360)*300;
                const osc1B=audioContext.createOscillator(),osc2B=audioContext.createOscillator();
                const gainBe=audioContext.createGain();
                osc1B.connect(gainBe);osc2B.connect(gainBe);gainBe.connect(audioContext.destination);
                osc1B.type='sine';osc1B.frequency.setValueAtTime(baseFreqB,audioContext.currentTime);
                osc2B.type='sine';osc2B.frequency.setValueAtTime(baseFreqB*1.5,audioContext.currentTime);
                gainBe.gain.setValueAtTime(0,audioContext.currentTime);
                gainBe.gain.linearRampToValueAtTime(vol*0.5,audioContext.currentTime+0.2);
                gainBe.gain.exponentialRampToValueAtTime(0.001,audioContext.currentTime+3.0);
                osc1B.start(audioContext.currentTime);osc1B.stop(audioContext.currentTime+3.0);
                osc2B.start(audioContext.currentTime);osc2B.stop(audioContext.currentTime+3.0);
                break;
            case 'piano':
                const notes=[261,294,330,349,392,440,494];
                const freqP=notes[Math.floor((colorValue/360)*notes.length)];
                const osc1P=audioContext.createOscillator(),osc2P=audioContext.createOscillator();
                const gainP=audioContext.createGain(),filterP=audioContext.createBiquadFilter();
                osc1P.connect(filterP);osc2P.connect(filterP);
                filterP.connect(gainP);gainP.connect(audioContext.destination);
                osc1P.type='triangle';osc1P.frequency.setValueAtTime(freqP,audioContext.currentTime);
                osc2P.type='sine';osc2P.frequency.setValueAtTime(freqP*2,audioContext.currentTime);
                filterP.type='lowpass';filterP.frequency.setValueAtTime(2000,audioContext.currentTime);
                gainP.gain.setValueAtTime(0,audioContext.currentTime);
                gainP.gain.linearRampToValueAtTime(vol*0.4,audioContext.currentTime+0.1);
                gainP.gain.exponentialRampToValueAtTime(0.001,audioContext.currentTime+1.5);
                osc1P.start(audioContext.currentTime);osc1P.stop(audioContext.currentTime+1.5);
                osc2P.start(audioContext.currentTime);osc2P.stop(audioContext.currentTime+1.5);
                break;
        }
    }catch(e){console.log('Audio error:',e);}
}

function drawMirrorPoint(x,y,size,color){
    const mirrors=parseInt(mode.value),angleStep=(Math.PI*2)/mirrors;
    const relX=x-centerX,relY=y-centerY,glowInt=glow.value/100;
    ctx.save();
    
    for(let i=0;i<mirrors;i++){
        const angle=i*angleStep,cos=Math.cos(angle),sin=Math.sin(angle);
        const rx=(relX*cos-relY*sin)+centerX,ry=(relX*sin+relY*cos)+centerY;
        const mx=(relX*cos+relY*sin)+centerX,my=(-relX*sin+relY*cos)+centerY;
        
        [rx,ry,mx,my].forEach((coord,idx)=>{
            if(idx%2===1)return;
            const px=coord,py=(idx<2)?ry:my;
            
            const outerGrad=ctx.createRadialGradient(px,py,0,px,py,size*2.5);
            outerGrad.addColorStop(0,`rgba(${color[0]},${color[1]},${color[2]},0.9)`);
            outerGrad.addColorStop(0.4,`rgba(${color[0]},${color[1]},${color[2]},0.5)`);
            outerGrad.addColorStop(1,'transparent');
            
            ctx.fillStyle=outerGrad;ctx.shadowBlur=25*glowInt;
            ctx.shadowColor=`rgba(${color[0]},${color[1]},${color[2]},0.8)`;
            ctx.beginPath();ctx.arc(px,py,size*1.5,0,Math.PI*2);ctx.fill();
            
            ctx.fillStyle=`rgba(${color[0]},${color[1]},${color[2]},0.95)`;
            ctx.shadowBlur=15*glowInt;ctx.beginPath();
            ctx.arc(px,py,size*0.7,0,Math.PI*2);ctx.fill();
        });
    }
    ctx.shadowBlur=0;ctx.restore();
}

function getColor(){
    const currentHue=(hue+time*0.5)%360,saturation=85+Math.sin(time*0.02)*15;
    const lightness=55+Math.cos(time*0.03)*20,h=currentHue/60;
    const c=(1-Math.abs(2*lightness/100-1))*saturation/100;
    const x_val=c*(1-Math.abs(h%2-1)),m=lightness/100-c/2;
    
    let r,g,b;
    if(h<1){r=c;g=x_val;b=0;}
    else if(h<2){r=x_val;g=c;b=0;}
    else if(h<3){r=0;g=c;b=x_val;}
    else if(h<4){r=0;g=x_val;b=c;}
    else if(h<5){r=x_val;g=0;b=c;}
    else{r=c;g=0;b=x_val;}
    
    return[Math.round((r+m)*255),Math.round((g+m)*255),Math.round((b+m)*255)];
}

function getAITarget(){
    const behavior=aiMode.value,radius=Math.min(canvas.width,canvas.height)*0.4;
    
    switch(behavior){
        case 'geometric':
            const sides=parseInt(mode.value);
            const angle=(phaseProgress*Math.PI*2)%(Math.PI*2/sides);
            const distance=radius*(0.3+Math.sin(phaseProgress*4)*0.4);
            return{x:centerX+Math.cos(angle*sides)*distance,y:centerY+Math.sin(angle*sides)*distance};
        case 'organic':
            const flowAngle=phaseProgress*Math.PI*4;
            const flowRadius=radius*(0.5+Math.sin(phaseProgress*6)*0.3);
            return{x:centerX+Math.cos(flowAngle)*flowRadius*Math.cos(phaseProgress*2),
                   y:centerY+Math.sin(flowAngle)*flowRadius*Math.sin(phaseProgress*3)};
        case 'spiral':
            const spiralAngle=phaseProgress*Math.PI*8;
            const spiralRadius=radius*Math.abs(Math.sin(phaseProgress*2));
            return{x:centerX+Math.cos(spiralAngle)*spiralRadius,y:centerY+Math.sin(spiralAngle)*spiralRadius};
        case 'mandala':
            const layer=Math.floor(phaseProgress*5);
            const layerAngle=(phaseProgress*20)%(Math.PI*2);
            const layerRadius=radius*(0.2+layer*0.15);
            return{x:centerX+Math.cos(layerAngle)*layerRadius,y:centerY+Math.sin(layerAngle)*layerRadius};
        case 'chaotic':
            return{x:centerX+(Math.random()-0.5)*radius*1.5,y:centerY+(Math.random()-0.5)*radius*1.5};
        default:
            return{x:centerX+(Math.random()-0.5)*radius*2,y:centerY+(Math.random()-0.5)*radius*2};
    }
}

function generateStep(){
    if(!isGenerating)return;
    const target=getAITarget();aiX+=(target.x-aiX)*0.15;aiY+=(target.y-aiY)*0.15;
    aiX+=(Math.random()-0.5)*3;aiY+=(Math.random()-0.5)*3;
    
    const color=getColor(),size=parseInt(brush.value);
    drawMirrorPoint(aiX,aiY,size,color);playSound(hue);
    
    phaseProgress+=0.005*(speed.value/50);
    if(phaseProgress>1)phaseProgress=0;
    hue=(hue+1)%360;time+=1;
}

function paint(x1,y1,x2,y2){
    const size=parseInt(brush.value),dx=x2-x1,dy=y2-y1;
    const dist=Math.sqrt(dx*dx+dy*dy),steps=Math.max(1,Math.ceil(dist/3));
    
    for(let i=0;i<=steps;i++){
        const t=i/steps,x=x1+dx*t,y=y1+dy*t,color=getColor();
        drawMirrorPoint(x,y,size,color);
        if(i===0)playSound(hue);
    }
    hue=(hue+dist*0.3)%360;
}

// Events
modeBtn.addEventListener('click',switchMode);
soundBtn.addEventListener('click',toggleSound);
recordBtn.addEventListener('click',startRecord);

canvas.addEventListener('mousedown',e=>{
    if(currentMode==='auto')return;
    isDrawing=true;lastX=e.clientX;lastY=e.clientY;paint(lastX,lastY,lastX,lastY);
});
canvas.addEventListener('mousemove',e=>{
    if(!isDrawing||currentMode==='auto')return;
    paint(lastX,lastY,e.clientX,e.clientY);lastX=e.clientX;lastY=e.clientY;
});
canvas.addEventListener('mouseup',()=>isDrawing=false);
canvas.addEventListener('touchstart',e=>{
    if(currentMode==='auto')return;e.preventDefault();isDrawing=true;
    const touch=e.touches[0];lastX=touch.clientX;lastY=touch.clientY;
    paint(lastX,lastY,lastX,lastY);
});
canvas.addEventListener('touchmove',e=>{
    if(!isDrawing||currentMode==='auto')return;e.preventDefault();
    const touch=e.touches[0];paint(lastX,lastY,touch.clientX,touch.clientY);
    lastX=touch.clientX;lastY=touch.clientY;
});
canvas.addEventListener('touchend',e=>{e.preventDefault();isDrawing=false;});

speed.addEventListener('input',()=>document.getElementById('speedVal').textContent=speed.value);
brush.addEventListener('input',()=>document.getElementById('brushVal').textContent=brush.value);
glow.addEventListener('input',()=>document.getElementById('glowVal').textContent=glow.value);
volume.addEventListener('input',()=>document.getElementById('volVal').textContent=volume.value);

clearCanvas();
</script>
</body></html>
