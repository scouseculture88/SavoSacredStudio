<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Kaleidoscope Tool</title>
<style>
    html, body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: #000;
        font-family: Arial, sans-serif;
        user-select: none;
    }
    #canvas {
        display: block;
    }
    #cursor {
        position: fixed;
        pointer-events: none;
        border-radius: 50%;
        z-index: 10;
        mix-blend-mode: difference;
    }
    #controls {
        position: fixed;
        top: 10px;
        left: 10px;
        background: rgba(0,0,0,0.8);
        color: #fff;
        padding: 10px;
        border-radius: 8px;
        max-height: 90vh;
        overflow-y: auto;
        transition: width 0.3s, height 0.3s;
    }
    #controls.minimized {
        width: 50px;
        height: 50px;
        overflow: hidden;
    }
    #controls button, #controls select, #controls input {
        margin: 4px 0;
        width: 100%;
    }
    .hidden { display: none; }
    .active { background: #2196F3; }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="cursor"></div>

<div id="controls">
    <button id="minimizeBtn" onclick="toggleControls()">−</button>
    
    <div id="brushInfo">
        Brush Size: <input type="range" id="brush" min="1" max="100" value="20"><span id="brushVal">20</span><br>
        Color Speed: <input type="range" id="colorSpeed" min="1" max="100" value="50"><span id="colorVal">50</span><br>
        Glow: <input type="range" id="glow" min="0" max="100" value="50"><span id="glowVal">50</span><br>
        Volume: <input type="range" id="volume" min="0" max="100" value="50"><span id="volVal">50</span><br>
    </div>
    
    <div id="modeInfo">
        Mirrors: <select id="mode"><option value="3">3</option><option value="4">4</option><option value="5">5</option><option value="6">6</option></select>
        <span id="mirrorCount"></span><br>
        Mode: 
        <button id="manualBtn" onclick="setGenerationMode('manual')">Manual</button>
        <button id="autoBtn" onclick="setGenerationMode('auto')">Auto</button>
        <button id="hybridBtn" onclick="setGenerationMode('hybrid')">Hybrid</button><br>
        <div id="autoSpeedGroup">
            Auto Speed: <input type="range" id="autoSpeed" min="1" max="100" value="50"><span id="autoSpeedVal">50</span>
        </div>
        <div>
            <button id="recordBtn" onclick="startRecord()">🎥 Record</button>
            <button id="soundBtn" onclick="toggleSound()">🔊 Enable Sounds</button>
            <select id="soundMode">
                <option value="harmonics">Harmonic Frequencies</option>
                <option value="chakra">Chakra Healing Tones</option>
                <option value="crystal">Crystal Bowl Resonance</option>
                <option value="nature">Nature Soundscapes</option>
                <option value="solfeggio">Solfeggio Sacred Frequencies</option>
                <option value="binaural">Binaural Beat Therapy</option>
                <option value="pentatonic">Pentatonic Scale Magic</option>
                <option value="ethereal">Ethereal Ambient Tones</option>
                <option value="cosmic">Cosmic Space Frequencies</option>
                <option value="meditation">Deep Meditation Bowls</option>
            </select>
        </div>
        <div id="colorDisplay"></div>
        <div id="modeDisplay">Mode: Manual</div>
    </div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const cursor = document.getElementById('cursor');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
});

let isDrawing = false, lastX=0, lastY=0, hue=0, time=0;
let currentColor = [255,20,147], generationMode='manual';
let autoX=canvas.width/2, autoY=canvas.height/2, autoAngle=0, autoRadius=100;
let mediaRecorder, recordedChunks=[], isRecording=false;
let audioContext, oscillators=[], soundEnabled=false;

// ===== Audio Functions =====
function initAudio() {
    if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
}

function toggleSound() {
    if (!soundEnabled) {
        initAudio();
        soundEnabled = true;
        document.getElementById('soundBtn').textContent = '🔇 Disable Sounds';
        document.getElementById('soundBtn').classList.add('active');
    } else {
        oscillators.forEach(o => { try{o.stop()}catch(e){} });
        oscillators=[];
        soundEnabled=false;
        document.getElementById('soundBtn').textContent = '🔊 Enable Sounds';
        document.getElementById('soundBtn').classList.remove('active');
    }
}

function getFrequency(color, mode){
    const [r,g,b]=color;
    const brightness=(r+g+b)/3;
    const hue=Math.atan2(Math.sqrt(3)*(g-b),2*r-g-b)*180/Math.PI;
    const normHue=((hue%360)+360)%360;
    let baseFreq;
    switch(mode){
        case 'harmonics': baseFreq=220+(normHue/360)*660; break;
        case 'chakra': const chakra=[194.18,210.42,226.32,341.3,384,426.7,480]; baseFreq=chakra[Math.floor((normHue/360)*chakra.length)]; break;
        case 'crystal': baseFreq=528+(brightness/255)*300; break;
        case 'nature': baseFreq=80+(normHue/360)*400; break;
        case 'solfeggio': const solf=[174,285,396,417,528,639,741,852,963]; baseFreq=solf[Math.floor((normHue/360)*solf.length)]; break;
        case 'binaural': baseFreq=200+(normHue/360)*200+Math.sin(time*0.01)*10; break;
        case 'pentatonic': const pent=[1,9/8,5/4,3/2,27/16]; baseFreq=220*pent[Math.floor((normHue/360)*pent.length)]; break;
        case 'ethereal': baseFreq=100+(brightness/255)*400+Math.sin(normHue/57.3)*50; break;
        case 'cosmic': baseFreq=55+(normHue/360)*880; break;
        case 'meditation': baseFreq=136.1+(brightness/255)*100; break;
        default: baseFreq=220+(normHue/360)*440;
    }
    return baseFreq*(0.7+(brightness/255)*0.6);
}

function playSound(color){
    if(!soundEnabled||!audioContext) return;
    try{
        const mode=document.getElementById('soundMode').value;
        const freq=getFrequency(color,mode);
        const vol=document.getElementById('volume').value/100;
        const osc=audioContext.createOscillator();
        const gain=audioContext.createGain();
        osc.connect(gain);
        gain.connect(audioContext.destination);
        switch(mode){
            case 'harmonics': case 'crystal': case 'solfeggio': case 'binaural': case 'ethereal': case 'meditation': osc.type='sine'; break;
            case 'chakra': case 'pentatonic': osc.type='triangle'; break;
            case 'nature': case 'cosmic': osc.type='sawtooth'; break;
            default: osc.type='sine';
        }
        osc.frequency.setValueAtTime(freq,audioContext.currentTime);
        gain.gain.setValueAtTime(0,audioContext.currentTime);
        gain.gain.linearRampToValueAtTime(vol*0.05,audioContext.currentTime+0.05);
        gain.gain.exponentialRampToValueAtTime(0.001,audioContext.currentTime+0.4);
        osc.start(audioContext.currentTime);
        osc.stop(audioContext.currentTime+0.5);
        oscillators.push(osc);
        if(oscillators.length>8) oscillators=oscillators.slice(-4);
    }catch(e){}
}

// ===== Canvas Functions =====
function drawMirror(x,y,size,color){
    const mirrors=parseInt(document.getElementById('mode').value);
    const angleStep=(Math.PI*2)/mirrors;
    const centerX=canvas.width/2, centerY=canvas.height/2;
    const relX=x-centerX, relY=y-centerY;
    const glowIntensity=document.getElementById('glow').value/100;
    ctx.save();
    for(let i=0;i<mirrors;i++){
        const angle=i*angleStep;
        const cos=Math.cos(angle), sin=Math.sin(angle);
        const fx=(relX*cos-relY*sin)+centerX;
        const fy=(relX*sin+relY*cos)+centerY;
        const mx=(-relX*cos-relY*sin)+centerX;
        const my=(-relX*sin+relY*cos)+centerY;
        [fx,mx].forEach((px,j)=>{
            const py=j?my:fy;
            const [r,g,b]=color;
            const grad=ctx.createRadialGradient(px,py,0,px,py,size);
            grad.addColorStop(0,`rgba(${r+50},${g+50},${b+50},0.95)`);
            grad.addColorStop(0.6,`rgba(${r},${g},${b},0.8)`);
            grad.addColorStop(1,'transparent');
            ctx.fillStyle=grad;
            ctx.beginPath();
            ctx.arc(px,py,size,0,Math.PI*2);
            ctx.fill();
            ctx.shadowColor=`rgb(${r},${g},${b})`;
            ctx.shadowBlur=25*glowIntensity;
            ctx.fillStyle=`rgba(${r},${g},${b},0.9)`;
            ctx.beginPath();
            ctx.arc(px,py,size*0.6,0,Math.PI*2);
            ctx.fill();
            ctx.shadowBlur=0;
        });
    }
    ctx.restore();
}

function paint(x1,y1,x2,y2){
    const size=parseInt(document.getElementById('brush').value);
    const shift=document.getElementById('colorSpeed').value/100;
    const dx=x2-x1, dy=y2-y1;
    const distance=Math.sqrt(dx*dx+dy*dy);
    const steps=Math.max(1,Math.floor(distance/4));
    hue+=distance*shift*0.8;
    for(let i=0;i<=steps;i++){
        const t=i/steps;
        const x=x1+dx*t, y=y1+dy*t;
        const h=(hue+i*shift*20)%360;
        const s=90+Math.sin(time*0.02)*10;
        const l=55+Math.cos(time*0.03)*15;
        const c=(1-Math.abs(2*l/100-1))*s/100;
        const xVal=c*(1-Math.abs((h/60)%2-1));
        const m=l/100-c/2;
        let r,g,b;
        if(h<60){r=c;g=xVal;b=0;} else if(h<120){r=xVal;g=c;b=0;} else if(h<180){r=0;g=c;b=xVal;} else if(h<240){r=0;g=xVal;b=c;} else if(h<300){r=xVal;g=0;b=c;} else {r=c;g=0;b=xVal;}
        const color=[Math.round((r+m)*255),Math.round((g+m)*255),Math.round((b+m)*255)];
        drawMirror(x,y,size*(1-t*0.15),color);
        if(i%5===0) playSound(color);
    }
}

function autoGenerate(){
    if(generationMode==='manual') return;
    const speed=document.getElementById('autoSpeed').value/100;
    autoAngle+=0.02*speed;
    autoRadius=100+Math.sin(autoAngle*2)*50;
    const centerX=canvas.width/2, centerY=canvas.height/2;
    const newX=centerX+Math.cos(autoAngle)*autoRadius;
    const newY=centerY+Math.sin(autoAngle)*autoRadius;
    const waveX=newX+Math.sin(time*0.05)*30;
    const waveY=newY+Math.cos(time*0.03)*30;
    if(autoX&&autoY) paint(autoX,autoY,waveX,waveY);
    autoX=waveX; autoY=waveY;
    currentColor=[
        128+Math.sin(time*0.01)*127,
        128+Math.sin(time*0.02)*127,
        128+Math.sin(time*0.03)*127
    ];
    updateColorDisplay();
}

// ===== Cursor & UI =====
function updateCursor(e){
    const size=parseInt(document.getElementById('brush').value);
    cursor.style.left=(e.clientX-size)+'px';
    cursor.style.top=(e.clientY-size)+'px';
    cursor.style.width=(size*2)+'px';
    cursor.style.height=(size*2)+'px';
    const [r,g,b]=currentColor;
    cursor.style.background=`rgba(${r},${g},${b},0.3)`;
}

function toggleControls(){
    const c=document.getElementById('controls'),btn=document.getElementById('minimizeBtn');
    const b=document.getElementById('brushInfo'),m=document.getElementById('modeInfo');
    c.classList.toggle('minimized');
    if(c.classList.contains('minimized')){
        btn.textContent='+';
        b.classList.remove('hidden'); m.classList.remove('hidden');
    } else {
        btn.textContent='−';
        b.classList.add('hidden'); m.classList.add('hidden');
    }
}

function setGenerationMode(newMode){
    generationMode=newMode;
    document.getElementById('manualBtn').classList.toggle('active',newMode==='manual');
    document.getElementById('autoBtn').classList.toggle('active',newMode==='auto');
    document.getElementById('hybridBtn').classList.toggle('active',newMode==='hybrid');
    document.getElementById('autoSpeedGroup').style.display=(newMode==='auto'||newMode==='hybrid')?'block':'none';
    document.getElementById('modeDisplay').textContent='Mode: '+newMode.charAt(0).toUpperCase()+newMode.slice(1);
}

function updateColorDisplay(){
    const [r,g,b]=currentColor;
    const d=document.getElementById('colorDisplay');
    d.textContent=`RGB(${r},${g},${b})`;
    d.style.color=`rgb(${r},${g},${b})`;
    d.style.textShadow=`0 0 10px rgb(${r},${g},${b})`;
}

function updateMirrorCount(){
    const mirrors=parseInt(document.getElementById('mode').value);
    document.getElementById('mirrorCount').textContent=`${mirrors}-way = ${mirrors*2} Reflections`;
}

function clearCanvas(){ctx.fillStyle='#000'; ctx.fillRect(0,0,canvas.width,canvas.height);}

function startRecord(){
    if(!isRecording){
        recordedChunks=[];
        const stream=canvas.captureStream(60);
        const q={high:12000000,standard:8000000,social:4000000};
        const bitrate=q[document.getElementById('recordQuality')?.value||'standard']||8000000;
        mediaRecorder=new MediaRecorder(stream,{videoBitsPerSecond:bitrate});
        mediaRecorder.ondataavailable=e=>{if(e.data.size>0)recordedChunks.push(e.data)};
        mediaRecorder.onstop=()=>{
            const blob=new Blob(recordedChunks,{type:'video/webm'});
            const url=URL.createObjectURL(blob);
            const a=document.createElement('a');
            a.href=url; a.download=`kaleidoscope_${Date.now()}.webm`; a.click();
            URL.revokeObjectURL(url);
            document.getElementById('recordBtn').textContent='🎥 Record';
        };
        mediaRecorder.start();
        isRecording=true;
        document.getElementById('recordBtn').textContent='⏹️ Stop';
        document.getElementById('recordBtn').classList.add('recording');
    } else {
        mediaRecorder.stop(); isRecording=false;
        document.getElementById('recordBtn').classList.remove('recording');
    }
}

// ===== Event Listeners =====
document.getElementById('mode').onchange=updateMirrorCount;
document.getElementById('brush').oninput=()=>{document.getElementById('brushVal').textContent=document.getElementById('brush').value};
document.getElementById('colorSpeed').oninput=()=>{document.getElementById('colorVal').textContent=document.getElementById('colorSpeed').value};
document.getElementById('glow').oninput=()=>{document.getElementById('glowVal').textContent=document.getElementById('glow').value};
document.getElementById('volume').oninput=()=>{document.getElementById('volVal').textContent=document.getElementById('volume').value};
document.getElementById('autoSpeed').oninput=()=>{document.getElementById('document.getElementById('autoSpeed').oninput = () => {
    document.getElementById('autoSpeedVal').textContent = document.getElementById('autoSpeed').value;
};

canvas.onmousedown = canvas.ontouchstart = e => {
    if (generationMode === 'auto') return;
    e.preventDefault();
    isDrawing = true;
    const touch = e.touches ? e.touches[0] : e;
    lastX = touch.clientX;
    lastY = touch.clientY;
    drawMirror(lastX, lastY, parseInt(document.getElementById('brush').value), currentColor);
    playSound(currentColor);
};

canvas.onmousemove = canvas.ontouchmove = e => {
    updateCursor(e);
    if (!isDrawing || generationMode === 'auto') return;
    e.preventDefault();
    const touch = e.touches ? e.touches[0] : e;
    paint(lastX, lastY, touch.clientX, touch.clientY);
    lastX = touch.clientX;
    lastY = touch.clientY;
};

canvas.onmouseup = canvas.ontouchend = () => isDrawing = false;
document.onmousemove = updateCursor;

function animate() {
    time++;
    if (generationMode === 'auto' || generationMode === 'hybrid') {
        autoGenerate();
    }
    requestAnimationFrame(animate);
}

// Initialize
clearCanvas();
updateColorDisplay();
updateMirrorCount();
animate();
</script>
</body>
</html>
